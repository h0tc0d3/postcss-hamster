<!DOCTYPE html><html lang="ru-RU"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="x-ua-compatible" content="ie=edge"><title>Hamster Framework</title><link href="style.css" rel="stylesheet"></head><body><div class="body__background"></div><div class="loading"><div class="loading__wrapper"><span class="loading__wrapper-circle_1"></span> <span class="loading__wrapper-circle_2"></span> <span class="loading__wrapper-circle_3"></span> <span class="loading__wrapper-circle_4"></span> <span class="loading__wrapper-circle_5"></span></div></div><div><input type="checkbox" id="ruler-debug"><label for="ruler-debug"></label><div class="ruler-debug"></div></div><nav class="sidebar__navigation"><ul class="sidebar__navigation-list"><li class="sidebar__navigation-item"><a class="sidebar__navigation-item_link" href="#introduction"><svg class="sidebar__navigation-item_icon icon-home"></svg> <span class="sidebar__navigation-item_text">Введение</span></a></li><li class="sidebar__navigation-item"><a class="sidebar__navigation-item_link" href="#installation"><span class="sidebar__navigation-item_icon icon-support"></span> <span class="sidebar__navigation-item_text">Установка</span></a></li><li class="sidebar__navigation-item"><a class="sidebar__navigation-item_link" href="#tuning"><span class="sidebar__navigation-item_icon icon-wrench"></span> <span class="sidebar__navigation-item_text">Настройка</span></a></li><li class="sidebar__navigation-item"><a class="sidebar__navigation-item_link" href="#settings"><span class="sidebar__navigation-item_icon icon-gear"></span> <span class="sidebar__navigation-item_text">Список настроек</span></a></li><li class="sidebar__navigation-item"><a class="sidebar__navigation-item_link" href="#practice"><span class="sidebar__navigation-item_icon icon-puzzle"></span> <span class="sidebar__navigation-item_text">Практика</span></a></li><li class="sidebar__navigation-item"><a class="sidebar__navigation-item_link" href="#helpers"><span class="sidebar__navigation-item_icon icon-code"></span> <span class="sidebar__navigation-item_text">Макросы и функции</span></a></li><li class="sidebar__navigation-item"><a class="sidebar__navigation-item_link" href="#advance"><span class="sidebar__navigation-item_icon icon-exclamation"></span> <span class="sidebar__navigation-item_text">Продвинутые функции</span></a></li></ul></nav><div class="wrapper"><main class="content"><section class="content__section" id="introduction"><h2>Введение</h2><p>Все из вас держали в руках яркие глянцевые журналы, читали газеты и книги, а может даже некоторые задавались вопросами: "Почему они выглядят так красиво, и сохраняют при этом высокую читабельность текста?! Почему многие вебсайты не выглядят так же красиво?! Почему чаще всего после верстки макета, дизайн сайта теряет свою изящность?!". Конечно же первоначальный дизайн имеет первостепенное значение в восприятии сайта в целом, но не маловажную роль играет способ организации контента на нем. И тут к нам на помощь приходят основные типографические понятия, как <strong>вертикальный ритм</strong> (<strong>vertical rhythm</strong>) и <strong>модульное масштабирование</strong> (<strong>modular scale</strong>, <strong>пропорциональное масштабирование</strong>, <strong>модульные шкалы</strong>. Я не смог найти точного описания термина на русском языке и в разных источниках упоминаются разные термины).</p><p>Дело в том, что в типографике весь контент выравнивается по вертикальным линейкам, внутри документа сохраняется один и тот же ритм - это вертикальный ритм.</p><div class="block-info">Например, если мы возьмем за одну линейку 24px(в данном случае единицы измерения не имеют значения, это могут быть любые единицы измерения, например 1em, 2rem, 1.5см), то условно мы делим весь документ на равные части по 24px и выравниваем все элементы страницы ровно между линейками.</div><p>Как это выглядит на практике вы можете посмотреть кликнув на иконку <span class="icon-grid"></span> в верхнем левом углу данного руководства. Преимущество такого подхода в том, что расстояние между элементами пропорциональное и надо меньше бегать глазами, чтобы перемещаться между элементами и найти их. За счет этого повышается читабельность текста и контента на странице.</p><p>Вторым не маловажным понятием является модульное масштабирование. Это когда есть базовый размер шрифта, а остальные размеры шрифта, которые мы можем использовать, получаются путем умножения или деления базового размера на число задающее коэффициент масштабирования.</p><div class="block-info">Например, это может быть число золотого сечения - <strong>1.618</strong>. Тогда, если мы возьмет за базовый шрифт <strong>16px</strong>, то следующий размер будет <strong>16 * 1.618 = 25.89px</strong>, последующий размер будет <strong>25.89 * 1.618 = 41.89px</strong> и т.д. Мелкие размеры относительно базового размера шрифта получаются путем деления на коэффициент масштабирования. Например: <strong>16 / 1.618 = 9.88px, 9.88 / 1.618 = 6.1px</strong> и т.д. Тем самым мы сохраняем пропорции внутри документа, и делаем его пропорциональным, что визуально смотрится приятнее. Иногда размеров шрифта относительно базового бывает не достаточно, чтобы обеспечить плавное масштабирование и могут возникать пустоты, тогда в этом случае базовый размер шрифта умножают на <strong>2</strong>, и получают дополнительные размеры шрифтов относительно дополнительного удвоенного размера. Наглядно это представлено на картинке ниже.</div><img class="block-center" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAhwAAAAuBAMAAACR/d3AAAAAFVBMVEX///8AAADMAADTNzMnJyclJSXTJiYdMSuRAAACFElEQVRo3u2VQZLjIAxFfzo265kbpOYEVOUCWfgAbLz3yvc/wnykuNXdFYcQQ/VGH4TkFPw4L9gAmG4aZXHWMIFhFzkd12BmHDjmPqGJxPab8/DcmRPYXhE9B46ah1zk1EBmJrUWtybG4nV31q+4PXdOGNOIV5QATpw1j0xJVh6Xmdn9MB8XTbe7hSS5TgUcYw2OlJgxc9mcuLIJDTNjASnmJsZs8wyG/dJxLuHAXINj/OSdyitfNTYzLRrtOnJIet8S+hVFHFW7I7dRzKUd1udONsiyxds9htuP3IY92fu2JJ05TJO8mblEequTZdrMBrAWc0YLDXRnlwLbKeNyuVyufvqDE1vuOli2GQ+XlY3f0glldXM+OQ7H4Tgch+NwHI7DcTiO38Hx1/VFcH3TP9cX4QL2D0BiG60ycdqeLijJTBvogl76cByOw3E4DsfhOByH43Acv4PD5XK5DmhdGQseSD8POdaVtaQqna8R1ysTaxbxrBcV+rlODOW6m5aAgEeSz5eMSgoO1TozooxSsIpstR7qErVkl+ilJSy7ONgWmXMQh9X1OOIPHFGuemlFCGH3YWETMIKD15U0InBlss1R/bBwAXu8r5Oi5+YIua+7u2MVBFsEVEkJSOgQ2dnecbHdIWUvLcDTd4fsjzdwGAFm9hY4Yn8c/PufnCyGg/OqHxaeAPeDwHDUnyz2sEToUdUBx3/ZPpTrTpIbFgAAAABJRU5ErkJggg==" alt="double stranded scale"><p>Распространенные коэффициенты масштабирования вы можете посмотреть на скане ниже. Источник скана книга <strong><em>Bringhurst’s “The Elements of Typographics Style.”</em></strong> <strong><em>Брингхерст Р. “Oсновы стиля в типографике.”</em></strong></p><img class="block-center" src="images/ratios.jpg" alt="Ratios"><p>Вам не нужно делать расчеты, чтобы сделать все это на вашем сайте. Все расчеты отступов и размеров для вас сделается автоматически плагин для PostCSS - <strong>PostCSS Hamster</strong>. Так же вам не стоит переживать, если заказчик попросит изменить размер шрифта, все автоматически сделает PostCSS Hamster, он пересчитает так же все отступы, чтобы все было по линейке. Вы можете прозрачно менять единицы измерения будь то em, rem, px. Все пересчитается автоматически. Все типовые расчеты для верстки веб страниц автоматизированы в PostCSS Hamster. Вам не нужно заниматься математикой и расчетами, на которую теряется много времени, вы можете сконцентрировать внимание на более важных вещах и например повысить адаптивность вашего веб сайта. На данный момент <strong>PostCSS Hamster</strong> является самым совершенным инструментом для поддержки типографики в среде веб разработки, притом на все расчеты уходит в среднем 35-58мс. Ни один существующий инструмент, кроме PostCSS Hamster не позволяет сделать это так быстро! Так же для работы вам не нужно обладать каким-то особыми навыками, автор постарался сделать синтаксис для работы с плагином простым и понятным даже новичкам. Чего например нет в конкурирующих продуктах где вам надо заморачиваться с кучей непонятных миксинов и параметров. Плюс по сравнению с конкурентами многие операции полностью автоматизированы и имеют большую гибкость!</p><p>Автор плагина провел не мало сотен часов за исследованием работы вертикального ритма в среде веб, а так же проблем связанных с поддержкой его в разных браузерах, включая такие старые браузеры, как internet explorer 6. Данные исследования послужили стимулом к созданию комплексного решения для поддержки вертикального ритма. Весь богатый опыт и рекомендации автора вы сможете получить в этом руководстве. Об установке и настройке <strong>PostCSS Hamster</strong> мы поговорим в следующей части.</p><div class="block-info">- Дорогой, пожалуйста, объясни как-нибудь сыну помягче, что его хомячок сдох.<br>- Сын, иди сюда! Отжимайся! 1,2,3,4,5,6...<br>- Все, не могу больше...<br>- Что?! Сдох?!!<br>- Да...<br>- Вот и хомяк твой тоже!!!<br>PS. Ваш хомяк для PostCSS никогда не сдохнет.</div></section><section class="content__section" id="installation"><h2>Установка</h2><img src="images/hamster.jpg" alt="hamster" width="600" class="block-center"><h3>Установка NODE.JS</h3><p>PostCSS Hamster работает в окружении NODE.JS и для его работы необходим установленный node.js на вашем компьютере или сервере. Если у вас еще не установлен <strong>NODE.JS</strong>, то вам необходимо пройти по ссылке <a href="https://nodejs.org/" target="_blank">https://nodejs.org/</a>, скачать последнюю доступную версию и установить её.</p><h3>Установка PostCSS Hamster</h3><p>Для работы вам необходима консоль. Если у вас нет готового проекта node.js, то вам нужно перейти в рабочую директорию проекта и инициализировать его командой:</p><div class="block-command">npm init</div><p>Дальше вам нужно установить необходимые расширения в существующий проект. Для этого в консоли вводим команду:</p><div class="block-command">npm install postcss-hamster --save-dev</div><p>PostCSS необходимый для работы модуля должен установиться автоматически, но если это не произошло по какой-то причине, то вы всегда можете установить его командой:</p><div class="block-command">npm install postcss --save-dev</div><p>Для запуска <strong>PostCSS Hamster</strong> вам необходимо создать файл с расширением <strong>.js</strong>, который будет обрабатывать ваши файлы. Содержимое скрипта находится ниже, и в нем необходимо заменить filename.css на имя вашего css файл, который будет обрабатываться, а outputfilename.css на имя выходного css файла. Это должны быть разные файлы!</p><div class="block-code"><pre><code class="language-js">var fs = require("fs"),
        postcss = require("postcss"),
        hamster = require("postcss-hamster"); 
fs.readFile("filename.css", "utf8", (err, css) => {
        postcss([hamster]).process(css).then(result => {
                fs.writeFileSync("outputfilename.css", result.css);
        });
});</code></pre></div><p>Для запуска процесса обработки css файла надо запустить команду:</p><div class="block-command">node имяфайла.js</div><div class="block-info">Если вы используете модули <strong>precss</strong> и <strong>cssnext</strong> для PostCSS, то в модуле precss необходимо отключить модуль lookup передав его имя со значением false в виде параметра при вызове <strong>precss({"lookup": false})</strong>, а в модуле cssnext необходим отключить функцию rem fallback - <strong>cssnext({features: {"rem": false}})</strong>. Данные модули конфликтуют с PostCSS Hamster и мешают работе. Не стоит беспокоиться, PostCSS Hamster компенсирует функциональность этих модулей и расширит ее!</div><p>Если вы используете gulp для сборки проекта, то содержимое <strong>gulpfile.js</strong> будет примерно как ниже:</p><div class="block-code"><pre><code class="language-js">var gulp = require("gulp"),
        sourcemaps = require("gulp-sourcemaps"),
        postcssgulp = require("gulp-postcss"),
        precss = require("precss"),
        autoprefixer = require("autoprefixer");
        hamster = require("postcss-hamster");

gulp.task("css", function () {
        var processors = [precss({
                "lookup": false
        }), hamster, autoprefixer({
                browsers: ["> 0.5%"]
        })];
        return gulp.src("./web/src/style.css")
            .pipe(sourcemaps.init())
            .pipe(postcssgulp(processors))
            // .pipe(cssnano())
            .pipe(sourcemaps.write("."))
            .pipe(gulp.dest("./web/css"));
});

gulp.task("default", ["css"]);</code></pre></div></section><section class="content__section" id="tuning"><h2>Настройка</h2><div class="block-iframe"></div><h3>Настройка PostCSS Hamster</h3><p>Для настройки проекта вам необходимо внести блок <strong>@hamster {}</strong> в ваш CSS файл.</p><div class="block-info">Будьте внимательны, блок настроек <strong>@hamster {}</strong> должен находится вначале вашего CSS файла. Если вы используется @import и подгружаете несколько CSS файлов, то блок @hamster {} должен находится вначале первого подгружаемого файла. Блок @hamster {} отвечает за глобальные настройки проекта, и если его использовать больше одного раза, то он будет перезаписывать глобальные настройки проекта. Это не хорошо, если вы работаете в команде разработчиков и у вас есть глобальные настройки, а каждый разработчик отвечает за свой модуль, в этом случае рекомендуется использовать локальные настройки <strong>@ihamster {}</strong>. Локальные настройки действуют до первого блока <strong>@hamster end;</strong>, после которого восстанавливаются глобальные настройки. Локальные настройки не перезаписывают полностью глобальные настройки, а переопределяют только заданные параметры. Так же если блок @ihamster {} будет встречаться несколько раз, то он не будет сбрасывать локальные настройки, а будет дополнять.</div><p>Как выглядят настройки вы можете посмотреть ниже. Не переживайте, если вы что-то не понимаете. Все параметры будут разъяснены ниже в документации.</p><div class="block-code"><pre><code class="language-css">@hamster {

    /*  Base settings */
    font-size: 16px;
    line-height: 1.5;

    font-ratio: minor-third;
    remove-comments: true;

    /*  Vertical Rythm settings */

    unit: em;
    px-fallback: true;
    properties: extend;
    ruler-style: switch ruler-debug;
    ruler-color: rgba(19, 134, 191, .8);
    ruler-icon-colors: #F0FAFF #ACFF0D;
    ruler-icon-position: "position: absolute;top: 1.5em;left: 1.5em;";
    ruler-background: png;
    /*ruler-output: images/ruler.png;*/
    ruler-pattern: 1 0 0 0;
    ruler-scale: 4;
    ruler-thickness: 1;

    /*  Custom contants */

    font-weight: 400;
    font-color: #44576a;
    header-color: #1386BF;
    background-color: #FAFDFF;
    block-color: #F0FAFF;
    hover-color: #1BBA13;
    footer-color: #1B2633;
    font-family: "Open Sans", "Segoe UI", "Helvetica Neue", Helvetica, Verdana, Tahoma, Arial, sans-serif;

}

/*  Или локальные настройки */

@ihamster {
    font-size: 18px;
    line-height: 24px;
}

@hamster end;</code></pre></div><h3 id="settings">Список настроек</h3><p><strong>font-size</strong> - Базовый размер шрифта, от которого будут производиться расчеты. Значение задается в px.</p><p><strong>line-height</strong> - Интерлиньяж (межстрочный интервал) и вертикальный ритм. Значение может быть в px или относительное значение без em, rem.</p><p><strong>unit</strong> - Единицы измерения которые будут в выходном CSS файле. Возможные значения: px, em, rem, vw.</p><p><strong>px-fallback</strong> - Если единицы измерения px, то в line-height вместо относительных значений будут значения в px. Например вместо line-height: 1.5; будет line-height: 24px;. Если единицы измерения em, то никаких изменений не происходит. Возможные значения true или false. true - опция включена, false - отключена.</p><p><strong>rem-fallback</strong> - Если единицы измерения rem, то для поддержки старых браузеров значения будут дублироваться в px.</p><p><strong>px-baseline</strong> - Принудительно включает значения размера шрифта в пикселях при установке базовой линии. По умолчанию значение false и значения размера шрифта будут в % - это дает лучшую поддержку, масштабируемость в старых браузерах. Опция необходима, если базовую линию собираетесь устанавливать несколько раз - например разрабатываете встраиваемый виджет для других сайтов. Возможные значения true или false.</p><p><strong>font-ratio</strong> - Коэффициент масштабирования для расчета размеров шрифта(modular scale ratio). Можно задавать как числовое значение, например 1.25, так и буквенное название. Буквенные названия возможных коэффициентов представлены ниже в таблице. В PostCSS Hamster создаются алиасы(буквенные названия размеров шрифта), которые вы можете использовать у себя в CSS файлах. Вы можете создавать свои алиасы, а так же переопределять их значения. Это помогает быстро сменить нужный размер шрифта, не переписывая кучу значений в ваших CSS файлах, что экономит много времени и ваших нервов. Если значение 0, то алиасы не создаются, но вы можете их создать самостоятельно. Подробнее использование алиасов мы рассмотрим в практической части. Ниже даны коэффициенты масштабирования и предопределенный список алиасов.</p><div class="tblock-center"><div class="content__table"><table><tr class="content__table-line_first"><td class="content__table-column">Name</td><td class="content__table-column">Ratio</td><td class="content__table-column">Value</td></tr><tr><td class="content__table-column">golden</td><td class="content__table-column">1:1.618</td><td class="content__table-column">1.618</td></tr><tr class="content__table-line"><td class="content__table-column">double-octave</td><td class="content__table-column">1:4</td><td class="content__table-column">4</td></tr><tr><td class="content__table-column">major-twelfth</td><td class="content__table-column">1:3</td><td class="content__table-column">3</td></tr><tr class="content__table-line"><td class="content__table-column">major-eleventh</td><td class="content__table-column">3:8</td><td class="content__table-column">2.667</td></tr><tr><td class="content__table-column">major-tenth</td><td class="content__table-column">2:5</td><td class="content__table-column">2.5</td></tr><tr class="content__table-line"><td class="content__table-column">octave</td><td class="content__table-column">1:2</td><td class="content__table-column">2</td></tr><tr><td class="content__table-column">major-seventh</td><td class="content__table-column">8:15</td><td class="content__table-column">1.875</td></tr><tr class="content__table-line"><td class="content__table-column">minor-seventh</td><td class="content__table-column">9:16</td><td class="content__table-column">1.778</td></tr><tr><td class="content__table-column">major-sixth</td><td class="content__table-column">3:5</td><td class="content__table-column">1.667</td></tr><tr class="content__table-line"><td class="content__table-column">minor-sixth</td><td class="content__table-column">5:8</td><td class="content__table-column">1.6</td></tr><tr><td class="content__table-column">fifth</td><td class="content__table-column">2:3</td><td class="content__table-column">1.5</td></tr><tr class="content__table-line"><td class="content__table-column">augmented-fourth</td><td class="content__table-column">1:√2</td><td class="content__table-column">1.414</td></tr><tr><td class="content__table-column">fourth</td><td class="content__table-column">3:4</td><td class="content__table-column">1.333</td></tr><tr class="content__table-line"><td class="content__table-column">major-third</td><td class="content__table-column">4:5</td><td class="content__table-column">1.25</td></tr><tr><td class="content__table-column">minor-third</td><td class="content__table-column">5:6</td><td class="content__table-column">1.2</td></tr><tr class="content__table-line"><td class="content__table-column">major-second</td><td class="content__table-column">8:9</td><td class="content__table-column">1.125</td></tr><tr><td class="content__table-column">minor-second</td><td class="content__table-column">15:16</td><td class="content__table-column">1.067</td></tr></table><table><tr class="content__table-line_first"><td class="content__table-column">Alias</td><td class="content__table-column">Short Alias</td><td class="content__table-column">Size</td></tr><tr><td class="content__table-column">tiny</td><td class="content__table-column">t</td><td class="content__table-column">-2</td></tr><tr class="content__table-line"><td class="content__table-column">small</td><td class="content__table-column">s</td><td class="content__table-column">-1</td></tr><tr><td class="content__table-column">base</td><td class="content__table-column">b</td><td class="content__table-column">0</td></tr><tr class="content__table-line"><td class="content__table-column">medium</td><td class="content__table-column">m</td><td class="content__table-column">1</td></tr><tr><td class="content__table-column">large</td><td class="content__table-column">l</td><td class="content__table-column">2</td></tr><tr class="content__table-line"><td class="content__table-column">xlarge</td><td class="content__table-column">xl</td><td class="content__table-column">3</td></tr><tr><td class="content__table-column">xxlarge</td><td class="content__table-column">xxl</td><td class="content__table-column">4</td></tr><tr class="content__table-line"><td class="content__table-column">xxxlarge</td><td class="content__table-column">xxxl</td><td class="content__table-column">5</td></tr></table></div></div><p><strong>properties</strong> - Метод записи свойств @nowrap, @forcewrap, @ellipsis в css файлах. Возможные значения: inline и extend. Если значение inline, то свойства будут записываться внутри css стиля. Если extend, то создастся новый css стиль в котором будут перечислены все селекторы. Если в extend всего один наследник, то свойство записывается inline.</p><p><strong>min-line-padding</strong> - Минимальный отступ в пикселях, для расчета количества линий, которое занимает размер шрифта. То-есть, если отступ до следующей линейки меньше данного значения, то добавляется еще одна линейка, чтобы разместить текст.</p><p><strong>ruler</strong> - Генерирует в CSS линейку для отладки вертикального ритма. Возможные значения true или false.</p><p><strong>ruler-style</strong> - Cтиль отладочной линейки. Формат: тип имякласса. Тип может быть: <strong>always</strong> - показывает линейку всегда, <strong>hover</strong> - показывать линейку при наведении на SVG иконку линейки, <strong>switch</strong> - использует CSS3 переключатель, который включает и выключает линейку. Имя класса - имя CSS класса в который запишется линейка. Для IE &lt;= 8 необходимо использовать always.</p><p><strong>ruler-icon-position</strong> - Расположение иконки линейки, например "position: absolute;top: 1.5em;left: 1.5em;". Обязательно в двойных кавычках!</p><p><strong>ruler-icon-colors</strong> - Цвета иконки линейки, разделитель пробел. Первый цвет обычное состояние иконки, второй цвет когда линейка включена.</p><p><strong>ruler-icon-size</strong> - Размер SVG иконки линейки в пикселях.</p><p><strong>ruler-color</strong> - Цвет линий отладочной линейки. Поддерживаются rgb - rgba(19, 134, 191), rgba - rgba(19, 134, 191, .8), hex - #454545, websafe - #333 цвета. Рекомендуется использовать альфа канал и не прозрачность 80%, чтобы линейка сильно не бросалась в глаза и не утомляла.</p><p><strong>ruler-thickness</strong> - Толщина линии линейки. Если линейка выдается через градиент, то это размер в %, если в PNG, то размер в пикселях.</p><p><strong>ruler-background</strong> - Фон линейки. Возможные значения: <strong>gradient</strong> - линейка будет как <strong>linear-gradiеnt</strong>, поддерживается только новыми браузерами, <strong>png</strong> - линейка будет сгенерирована в виде PNG картинки.</p><p><strong>ruler-output</strong> - Способ записи PNG линейки. По умолчанию значение base64 - линейка будет записана в CSS в виде base64 data uri. Остальные значения указывают на имя файла в который будет записана линейка, что необходимо при отладке в старых браузерах, не поддерживающих base64.</p><p><strong>ruler-pattern</strong> - Узор PNG линейки. Разделитель пробел. 0 - прозрачный пиксель, 1 - цветной пиксель линии линейки.</p><p><strong>ruler-scale</strong> - Коэффициент масштабирования PNG линейки, это число во сколько раз увеличится размер PNG линейки. На 4к мониторах линейка в масштабе 1 к 1 размывается из-за увеличения картинки в браузере, для решения этой проблемы используется картинка большего разрешения, которая легко может быть увеличена и сохранит четкость линий. Работает только в IE &gt;= 9. Для старых браузеров рекомендуемое значение 1, для 4к мониторов - 4.</p><p><strong>browser-font-size</strong> - Размер шрифта браузера в px. По умолчанию во всех браузерах стоит 16px. Опция необходима, если вы делаете расчеты для нестандартного браузера. В большинстве случаев рекомендуется оставить значение неизменным.</p><p><strong>legacy-browsers</strong> - Поддержка старых браузеров при единицах измерения px. Если опция включена, то при установке базовой линии значение размера шрифта будет в % и добавиться селектор <strong>* html</strong> со значением межстрочного интервала, иначе значение в px. Не стоит путать с px-baseline, которая включает принудительно пиксели, при всех единицах измерения. Возможные значения true или false.</p><p><strong>viewport</strong> - Задает размер видимой области для которой будет расчитаны значения calc c vw единицах измерения.(Динамические изменяемый размер шрифта в зависимости от размера экрана). Пример: <strong>800px 1920px</strong> - указывает нижнюю и верхнюю границу ширины экрана. Для расчета должны быть устанолены: unit: vw. font-size - указывает минимальный размер шрифта при минимальном размере экрана. line-height - указывает минимальный размер высоты линии. to-font-size и to-line-height.</p><p><strong>to-font-size</strong> - Задает максимальный размер шрифта для viewport.</p><p><strong>to-line-height</strong> - Задает максимальный размер высоты линии для viewport.</p><p><strong>use-global</strong> - Если опция включена(true), то высчитывается соотношение локального размера шрифта и глобального, ratio = localFontSize / globalFontSize. И все значения будут умножены на это соотношения, что позволяет использовать адаптивные размеры в rem и em без установки базовой линии.</p><div class="block-code"><pre><code class="language-css">
@media screen and (min-width: 1920px){
    @ihamster {
        --font-size: 21px;
        --line-height: 1.5;
        --to-font-size: 42px;
        --to-line-height: 1.6;
        --viewport: 1920px 3840px;
        --unit: vw;
    }
    @ruler;
    @paste full;
    @hamster end;
}</code></pre></div><p><strong>remove-comments</strong> - Удаляет все CSS комментарии. Возможные значения true или false.</p><p><strong>font-sizes</strong> - Добавляет и переопределяет алиасы для размеров шрифтов, разделитель ",". Синтаксис: алиас размервпикселях относительныйразмер. Относительный размер записывается без em и rem. Если какой-то из размеров отсутствует, то он сгенерируется автоматически относительно базового размера. Пример: <strong>font-sizes: fsize1 24px 1.5, fsize2 18px, fsize3 1.78;</strong>.</p><p>Так же в блоке <strong>@hamster</strong> вы можете задать константы, которые потом сможете использовать у себя в проекте. Для получения значения константы перед ее именем надо добавить <strong>@</strong>. Пример использования констант представлен ниже. <strong>@hamster reset;</strong> - сбрасывает все глобальные настройки в начальные значения.</p><div class="block-code"><pre><code class="language-css">html {
    font-family: @font-family;
    color: @font-color;
    font-weight: @font-weight;
}</code></pre></div><h3>Значения глобальных настроек по умолчанию</h3><div class="block-code"><pre><code class="language-css">font-size: 16px;
line-height: 1.5;
unit: em;
px-fallback: true;
px-baseline: false;
font-ratio: 0;

properties: inline;

min-line-padding: 2px;

ruler: true;
ruler-style: always ruler-debug;
ruler-icon-position: "position: absolute;top: 1.5em;left: 1.5em;";
ruler-icon-colors: #cccccc #44576a;
ruler-icon-size: 24px;
ruler-color: rgba(19, 134, 191, .8);
ruler-thickness: 1;
ruler-background: gradient;
ruler-output: base64;
ruler-pattern: 1 0 0 0;
ruler-scale: 1;

browser-font-size: 16px;
legacy-browsers: true;
remove-comments: false;</code></pre></div></section><section class="content__section" id="practice"><h2>Практическое применение</h2><div class="block-iframe"></div><p>Первым делом вам необходимо подготовить ваши html и css файлы к работе. В html файл надо добавить div для отображения линейки. DIV надо добавить в контейнер в котором мы будет отлаживать вертикальный ритм. <strong>PostCSS Hamster</strong> позволяет отлаживать вертикальный ритм в любом контейнере и линейка подстраивается под родительский контейнер!</p><p>Для <strong>ruler-style: switch</strong> html код будет таким:</p><div class="block-code"><pre><code class="language-html">&lt;div&gt;
    &lt;input type="checkbox" id="ruler-debug" /&gt;
    &lt;label for="ruler-debug">&lt;/label&gt;
    &lt;div class="ruler-debug">&lt;/div&gt;
&lt;/div>
</code></pre></div><p>В остальных случаях:</p><div class="block-code"><pre><code class="language-html">&lt;div class="ruler-debug">&lt;/div&gt;</code></pre></div><p>В html коде необходимо заменить <strong>ruler-debug</strong> на имя вашего класса линейки, который вы указали в настройках PostCSS Hamster.</p><div class="block-info">Для удобной работы с вертикальным ритмом в CSS вначале необходимо сбросить стили или использовать normalize. Вам нет необходимости скачивать reset или normalize, они уже включены в PostCSS Hamster. Для сброса стилей вам необходимо включить макрос <strong>@reset;</strong> в самом начале вашего css файла. Для reset используется <strong>Eric Meyer's “Reset CSS” 2.0</strong>. Для использования последней официальной версии Normalize.css, вам необходимо включить макрос <strong>@normalize;</strong> в самом начале вашего css файла. По моим наблюдениям для работы с типографикой больше подходит reset и вам придется меньше переопределять css стили. Так же если вы используете reset или normalize из состава PostCSS Hamster, то в них внесены небольшие изменения, и базовая линия в них устанавливается автоматически. Внесенные изменения вы сможете найти по комментариям в соответствующих файлах в папке helpers, из которой подгружаются reset и normalize. @reset и @normalize надо вызывать строго после блока @hamster!<br><br>Чтобы отладочная линейка правильно растягивалась по ширине экрана необходимо в селектор <strong>body</strong> добавить свойства <strong>position: relative; height: 100%;</strong>. Так же если вы хотите, чтобы линейка растягивалась не на весь экран, а только на контейнер содержащий ее, то в свойства контейнера надо добавить <strong>position: relative;</strong>.<br><br>Для включение CSS кода отладочной линейки надо добавить макрос <strong>@ruler;</strong></div><p>После всех действий и настроек, CSS файл должен принять вид примерно как ниже:</p><div class="block-code"><pre><code class="language-css">@hamster {

    /*  Base settings */
    font-size: 16px;
    line-height: 1.5;

    font-ratio: minor-third;
    remove-comments: true;

    /*  Vertical Rythm settings */

    unit: em;
    px-fallback: true;
    properties: extend;
    ruler-style: switch ruler-debug;
    ruler-color: rgba(19, 134, 191, .8);
    ruler-icon-colors: #F0FAFF #ACFF0D;
    ruler-icon-position: "top: 1.5em;left: 1.5em;";
    ruler-background: png;
    /*ruler-output: images/ruler.png;*/
    ruler-pattern: 1 0 0 0;
    ruler-scale: 4;
    ruler-thickness: 1;

    /*  Custom contants */

    font-weight: 400;
    font-color: #44576a;
    header-color: #1386BF;
    background-color: #FAFDFF;
    block-color: #F0FAFF;
    hover-color: #1BBA13;
    footer-color: #1B2633;
    font-family: "Open Sans", "Segoe UI", "Helvetica Neue", Helvetica, Verdana, Tahoma, Arial, sans-serif;

}

@reset;

body {
    font-family: @font-family;
    color: @font-color;
    font-weight: @font-weight;
    position: relative;
    height: 100%;
}

@ruler;</code></pre></div><h3 id="helpers">Макросы и функции</h3><p><strong>@baseline;</strong> - Устанавливает базовую линию. Установка базовой линии - это установки точки отсчета для вертикального ритма, при котором записываются значения базового размера шрифта и межстрочного интервала. От базовых размеров происходит дальнейшее масштабирование относительных размеров элементов и их свойств. Синтаксис: <strong>@baseline;</strong> - установка базовой линии внутри стиля, работает с <strong>px</strong> и <strong>em</strong>. Так как, <strong>rem</strong> единицы всегда масштабируются относительно размера шрифта элемента html, то установить базовую линии в документе можно 1 раз и только в элементе html. <strong>@baseline html;</strong> - записывает базовую линию, создав стиль с селектором <strong>html</strong>, если <strong>unit: px</strong> и <strong>legacy-browsers: true</strong>, то еще запишется стиль с селектором <strong>* html {}</strong>, содержащий межстрочный интервал. Это необходимо для лучшей поддержки устаревших браузеров. Пример использования смотрите ниже.</p><div class="block-code"><pre><code class="language-css">body {
    font-family: @font-family;
    color: @font-color;
    font-weight: @font-weight;
    position: relative;
    height: 100%;
    @baseline;
}

/* Или */

@baseline html;</code></pre></div><p><strong>@reset;</strong> - Добавляет Eric Meyer's “Reset CSS” 2.0.</p><p><strong>@normalize;</strong> - Добавляет Normalize.css.</p><p><strong>@sanitize;</strong> - Добавляет sanitize.css(форк normalize).</p><p><strong>@box-sizing-reset;</strong> - Добавляет box-sizing reset.</p><p><strong>@copy name1 {}</strong> - Копирует css код в фигурных скобках в переменную name1.(name1 - произвольное имя переменной)</p><p><strong>@paste name1;</strong> - Вставляет css код из переменной name1.</p><p><strong>@nowrap;</strong> - Добавляет <strong>white-space: nowrap;</strong> Пробелы не учитываются, переносы строк игнорируются, весь текст отображается одной строкой. Тег &lt;br&gt; переносит текст на новую строку.</p><p><strong>@forcewrap;</strong> - Добавляет <strong>white-space: pre; white-space: pre-line; white-space: pre-wrap; word-wrap: break-word;</strong>. Принудительно вписывает длинный текст в контейнер, чтобы он не нарушал макет. Например есть длинная строка или слово, которые браузер не знает как правильно перенести на следующую строку. Он не может перенести ее и она будет вылезать из контейнера. Свойство принудительно включает перенос на следующую строку. Пример реализован в блоке <strong>.block-code</strong>.</p><p><strong>@ellipsis;</strong> - Добавляет <strong>overflow: hidden; text-overflow: ellipsis;</strong>. Вписывает текст в прямоугольник контейнера и отображает только часть текста, которая вместилась в размер контейнера. Смотрите пример ниже.</p><p><strong>@ellipsis true;</strong> - То же самое, что @ellipsis; и @nowrap; одновременно.</p><div class="ellipsis">Длинный текст, который будет вписан в прямоугольник контейнера.</div><p><strong>@hyphens;</strong> - Добавляет <strong>word-wrap: break-word; hyphens: auto;</strong>. Включает автоматический перенос слов в тексте, что делает текст более читаемым чем с text-align: left; или text-align: justify;</p><p><strong>@break-word;</strong> - Добавляет <strong>word-break: break-word; word-break: break-all;</strong>. Разрешает жесткий перенос слов на следующую строку. Будьте внимательны, @break-word может ломать слова где угодно. @hyphens; делает перенос на следующую строку более мягко.</p><p><strong>@hyphens true;</strong> - То же самое, что @break-word;, а затем @hyphens;.</p><p><strong>fontsize</strong> или короткая запись <strong>fs</strong> - Записывает размер шрифта в unit(единицы измерения установленные в настройках) вместо буквенного алиаса. Синтаксис: <strong>fs alias[$unit][@x2, @d2 ]</strong>. <strong>@x2</strong> - считает размер относительно увеличенного в двое базового шрифта. <strong>@d2</strong> - считает размер относительно уменьшенного в двое базового шрифта. Например: <strong>fs xxxl</strong>, <strong>fs xxxl$px</strong> - принудительно запишет размер шрифта в пикселях, что удобно например использовать в сторонних функциях, <strong>fs 3$em@x2</strong> - запишет 3 размер шрифта относительно увеличенного в двое базового размера. Так же можно указывать относительный размер, например: <strong>fs -2</strong>, <strong>fs 0</strong> - базовый размер, <strong>fs 3</strong>. Примеры использования смотрите ниже.</p><div class="block-code"><pre><code class="language-css">font-size: fontsize base;

background: @text2svg "My best logo", "fontfile.ttf", fontSize fsize1$px, #fff;</code></pre></div><p><strong>adjust-font-size</strong> - Переданный в параметрах размер шрифта переводит в единицы измерения, установленные в настройках. Установит рассчитанный размер в свойстве <strong>font-size</strong>, рассчитает для него количество занимаемых линий, и запишет свойство <strong>line-height</strong>. Формат: <strong>adjust-font-size: размер [количество занимаемых линий] [базовый размер шрифта]</strong>. Если вас не устраивает количество рассчитанных линий, то вы можете указать вручную количество занимаемых линий, а так же размер шрифта относительно, которого будут вестись расчеты. Примеры: <strong>adjust-font-size: 2em;</strong>, <strong>adjust-font-size: fontsize xxxl;</strong>, <strong>adjust-font-size: fontsize large 4;</strong>, <strong>adjust-font-size: fontsize small 2 18px;</strong>.</p><p><strong>rhythm</strong> и <strong>!rhythm</strong> - Округляет значение переданное в параметрах, чтобы оно вмещало целое число линеек. <strong>rhythm</strong> округляет в меньшую сторону, а <strong>!rhythm</strong> в большую. Пример: <strong>rhythm(450px)</strong> - 432px, <strong>!rhythm(450px)</strong> - 456px. Формат: <strong>rhythm(значение[$выходные единицы измерения] [размер шрифта], ...)</strong>. По умолчанию выходные единицы равны unit указанные в настройках. Пример: <strong>rhythm(450px$em 18px, 430px$em 18px)</strong>.</p><p><strong>spacing</strong> и <strong>lineheight</strong> (<strong>lheight</strong>) - переводят количество линий в unit. В параметрах можно передать не только целые числа, но так же дробные, и числа меньше 1. Отличие в работе у <strong>spacing</strong> и <strong>lineheight</strong> есть только при unit: px и px-fallback: false, <strong>spacing </strong>- всегда будет возвращать значение в пикселях, а lineheight может вернуть относительное значение, как например 1.5, без единиц измерения. <strong>spacing</strong> - подходит больше для установки отступов, <strong>lineheight</strong> - для установки значения свойства <strong>line-height</strong>. Формат: <strong>spacing([количество] [размер шрифта], ...)</strong>, <strong>lineheight([количество] [размер шрифта], ...)</strong>. Реальные примеры использования смотрите в блоке кода, расположенного чуть ниже.</p><p><strong>base</strong> - умножает число переданное параметром на базовый размер шрифта и возвращает полученное значение.</p><p><strong>leading</strong> - переводит количество leading в unit. leading условно равен базовый межстрочный интервал минус базовый размер шрифта. Используется для расчета отступов. Для наглядности смотрите картинку ниже. Формат: <strong>leading([количество] [размер шрифта], ...)</strong>. Реальные примеры использования смотрите в блоке кода, расположенного чуть ниже.</p><img src="images/line-height.png" alt="line height" width="500" class="block-center"><div class="block-info">Размер шрифта, это не базовый размер шрифта, а размер шрифта элемента. Если внутри стиля есть свойство font-size, то функция использует его, иначе берет базовый размер шрифта. Если вас не устраивает базовый размер шрифта, то в параметрах можете передать нужный размер. <strong>, ...</strong> обозначает, что можно указать несколько значений разделенных запятой, в выходном файле значения будут разделены пробелом. Реальные примеры использования смотрите в блоке кода, расположенного чуть ниже.</div><h4>Кнопки</h4><div class="block-margin"><a href="#" class="button-blue" title="Button Blue" target="_blank">Get started</a> <a href="#" class="button-gray" title="Button Gray" target="_blank">Get started</a> <a href="#" class="button-violet" title="Button Violet" target="_blank">Get started</a></div><h4>Информационный блок</h4><div class="block-info">Очень важная информация.</div><h4>Блок кода</h4><div class="block-code">Здесь мог бы быть ваш код!</div><div class="block-code"><pre><code class="language-css">/* Variables. */

@hamster {
    font-color: #44576a;
    header-color: #1386BF;
    background-color: #FAFDFF;
    block-color: #F0FAFF;
    hover-color: #1BBA13;
}

header {
    margin-top: auto;
    margin-bottom: auto;
    height: rhythm(270px);
    /*height: 264px;*/
    background-image: url("../images/header.jpg");
    background-position: center center;
}

/* Buttons source code. */

%button {
    display: inline-block;
    adjust-font-size: fontSize t;
    /*Padding minus border size*/
    padding: spacing(.25, 1.5);
    margin-top: spacing(.25);
    margin-bottom: spacing(.25);
    border-radius: leading(.25);
    font-weight: 500;
    text-align: center;
    text-decoration: none;
    text-transform: uppercase;
    box-shadow: 0 leading(.1, .25) rgba(0, 0, 0, 0.25);
    transition: all .3s ease-in-out;
}

@define-mixin button $name, $color {
    .button-$name {
        @extend %button;
        background-color: $color;
        color: #fff;
        /*border: leading(.1) solid $color;*/
        &:hover {
            background-color: @background-color;
            color: $color;
            transition: all .3s ease-in-out;
        }
    }
}

@mixin button blue, @header-color;
@mixin button gray, @font-color;
@mixin button green, @hover-color;

/* Blocks source code. */

$block-font-size: xlarge@d2;

%block {
      adjust-font-size: fontSize $block-font-size;
      margin-top: spacing(1);
      margin-bottom: spacing(1);
      padding: spacing(1);
      text-align: left;
      font-weight: 400;
      clear: both;
      border-radius: leading(.5);
      overflow: hidden;
 }

.block-info {
    @extend %block;
    @hyphens;
    font-style: italic;
    background: @block-color;
    padding-left: spacing(4 fontSize $block-font-size);
    background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' preserveAspectRatio='none slice' viewBox='0 0 8 8'%3E%3Cpath fill='%231386BF' d='M4.4 5.324h-.8v-2.46h.8zm0 1.42h-.8V5.89h.8zM3.76.63L.04 7.075c-.115.2.016.425.26.426h7.397c.242 0 .372-.226.258-.426C6.726 4.924 5.47 2.79 4.253.63c-.113-.174-.39-.174-.494 0z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-size: spacing(2 fontSize $block-font-size, 2 fontSize $block-font-size);
    background-position: spacing(1 fontSize $block-font-size) center;
}

.block-code {
    @extend %block;
    background: @code-color;
    font-weight: 400;
    color: @font-color;
    background-repeat: no-repeat;
    background-position: spacing(1 fontSize $block-font-size, 0.5 fontSize $block-font-size);
    background-size: spacing(2 fontSize $block-font-size, 2 fontSize $block-font-size);*/
}</code></pre></div><div class="block-info">Более подробный пример использования вы можете посмотореть в исходном коде данного руководства, расположенного в директори <a href="https://github.com/h0tc0d3/postcss-hamster/tree/master/web/src" target="_blank">web/src/</a>.</div></section><section class="content__section" id="advance"><h2>Продвинутые функции</h2><p>К сожалению, все проблемы связанные с поддержкой вертикального ритма в веб, мы не можем решить с помощью CSS. По этой причине, для решения остальных задач, в комплект <strong>PostCSS Hamster</strong> включена клиентская <strong>JS</strong> библиотека для браузеров - <strong>rhythm</strong>. Исходный код библиотеки вы можете найти в директории <a href="https://github.com/h0tc0d3/postcss-hamster/tree/master/web/js" target="_blank">web/js/</a>, а готовый к использованию файл <strong>rhythm.min.js</strong> лежит в директории <a href="https://github.com/h0tc0d3/postcss-hamster/tree/master/build/web" target="_blank">build/web/</a>. Реальный пример использования вы можете найти в файле <strong>app.es6</strong>. Так же код библиотеки был оптимизирован по скорости работы и не использует сторонних библиотек типа jquery. Изначально код был написан под jquery и поддерживал все браузеры IE6+, но потом было принято решение перейти на натив <strong>javascript</strong>, что дало значительный прирост в производительности и сократило размер подключаемых файлов в 10 раз. Библиотека работает исправно в браузерах IE9+. Код проекта был спроектирован так, что его можно адаптировать под более старые браузеры и для их поддержки присутствует код, но babel es6 транспайлер экспортирует файл для IE9+.</p><h3>Вертикальный ритм для картинок, фреймов и блочных элементов</h3><img src="images/hamster2.jpg" alt="hamster" height="400" class="block-right"><p>Вы наверное обратили внимание, что в данном руководстве есть картинки и фреймы не относящиеся к нему. Это было сделано специально, чтобы наглядно показать, как поддерживать для них вертикальный ритм. Для поддержки вертикального ритма этих элементов существует несколько способов:</p><ol><li>Можно изменить высоту элемента, и масштабировать его с сохранением пропорции, чтобы вписать его в существующий ритм.</li><li>Добавить отступ сверху, снизу, или сразу сверху и снизу.</li></ol><p>Все эти способы поддерживаются библиотекой rhythm входящей в состав <strong>PostCSS Hamster</strong>.</p><h3>Настройка</h3><p>Для настройки библиотеки rhythm необходимо передать настройки в конструктор класса. Глобальные настройки мы рассмотрим ниже.</p><p><strong>property</strong> - Какое CSS свойство будет компенсировать вертикальный ритм. Возможные значения height-up, height-down, !height-up, !height-down, margin, padding, margin-bottom, margin-top, padding-bottom, padding-top. height-up - высота элемента будет увеличена до следующей линейки. height-down - высота элемента будет уменьшена до предыдущей линейки, подходит для картинок, так как уменьшение размера меньше сказывается на качестве картинки. !height-up, !height-down - тоже самое, что height-up и height-down, но будет изменена только высота и пропорции элемента изменятся. margin - сверху и снизу будет добавлен одинаковый margin. padding - сверху и снизу будет добавлен одинаковый padding. margin-top - будет добавлен margin сверху. margin-bottom - будет добавлен margin снизу. padding-top - будет добавлен padding сверху. padding-bottom - будет добавлен padding снизу.</p><p><strong>base</strong> - Базовый размер шрифта в пикселях. Без суффикса px.</p><p><strong>line</strong> - Высота межстрочного интервала, вертикальный ритм. Можно указать значение в пикселях и относительное значение без единиц измерения.</p><p><strong>resize</strong> - Разрешает перерасчет вертикального ритма для элементов, если был изменен размер видимой области. Например при повороте экрана планшета. Возможные значения true и false.</p><p><strong>resizeWidth</strong> - Разрешает изменять ширину элементов. Например мы меняем высоту и нам нужно сохранить пропорции сторон элемента. Так же если элемент по ширине больше ширины родительского контейнера, то он будет подогнан по ширине родительского контейнера, чтобы верстка не расползалась. Возможные значения true и false.</p><p><strong>classPrefix</strong> - Префикс для классов компенсируемых элементов. Библиотека сохраняет оригинальные размеры элементов и чтобы их идентифицировать добавляется класс с префиксом и порядковым номером элемента.</p><p><strong>brakePoints</strong> - Задает размеры шрифта и межстрочного интервала для разных размеров экрана. min - минимальный размер экрана, max - максимальный размер экрана. Пример:</p><div class="block-code"><pre><code class="language-js">let settings = {
    "property": "height-down",
    "brakePoints": [
        {min: 0, max: 480, base: 14, line: 1.25},
        {min: 480, max: 600, base: 15, line: 1.3},
        {min: 600, max: 800, base: 16, line: 1.35},
        {min: 800, max: 1280, base: 18, line: 1.4},
        {min: 1280, max: 1600, base: 19, line: 1.5},
        {min: 1600, max: 1920, base: 20, line: 1.55},
        {min: 1920, max: 9999, base: 21, line: 1.6}
    ]
};</code></pre></div><p><strong>dynamic: true</strong> - Автоматически расчитывает высоту линии.</p><p><strong>dynamicSelector</strong> - Селектор элемента для которого будет расчитана высота линии.</p><div class="block-code"><pre><code class="language-js">let settings = {
    "property": "height-down",
    "dynamic": true,
    "dynamicSelector": "p"
};</code></pre></div><p>Настройки по умолчанию представлены ниже. Вам не обязательно указывать все настройки и если какие-то настройки не указаны, то вместо них будут использоваться значение по умолчанию.</p><div class="block-code"><pre><code class="language-js">var settings = {
    // Property for compensation. height-up, height-down, !height-up, !height-down, margin, padding, margin-bottom, margin-top, padding-bottom, padding-top
    "property": "padding",
    // Rhythm base font size, without "px".
    "base": 16,
    // Rhythm Line height. Relative or pixel size.
    "line": 1.5,
    // Resize if screen width changed.
    "resize": true,
    // Allow resize width of element
    "resizeWidth": true,
    // Uniq class prefix
    "classPrefix": "rhythmHamster",
    // Fix properties with relative values to round pixels
    "properties": [
        "line-height",
        "padding-top",
        "padding-bottom",
        "margin-top",
        "margin-bottom",
        "padding-left",
        "padding-right",
        "margin-left",
        "margin-right",
    ]
};

var irhythm = new Rhythm(settings);
</code></pre></div><p>Для компенсации вертикального ритма у экземпляра класса надо вызвать метод rhythm. Первым параметром в кавычках передаются селекторы через запятую, для которых будет компенсироваться вертикальный ритм. Второй и третий параметры не обязательны. Второй параметр указывает на компенсируемое свойство. Если параметр не передан, то используются глобальные настройки. Третий параметр разрешает или запрещает изменять ширину элемента. Например мы хотим увеличить высоту отдельного элемента, но не хотим менять ширину.</p><div class="block-info">Так как все манипуляции с элементами можно осуществить только после того, как документ был полностью загружен, то в rhytm встроен обработчик события document ready и window load, которые вы можете использовать. Так же события document ready и window load срабатывают иногда раньше, чем браузер просчитает все CSS значения. Так как библиотека использует просчитанные браузером значения CSS свойств, то надо дождаться момента когда браузер это сделает. К сожалению я не нашел эффективного способа найти этот момент(браузер отдает 0 или совсем не правильно просчитаное значение), и для решение это проблемы необходимо использовать <strong>window.setTimeout</strong> со значением 500-1000мс при document ready и 100-500мс при windows load. В старых браузерах и на слабых компьютерах минимальных значений бывает не достаточно. Значение задержки надо подбирать экспериментально в зависимости от сложности документа. Для подбора значения необходимо несколько раз обновить страницу в браузере, и если элементы не плывут, то зафиксировать это значение. Пример использования библиотеки представлен ниже в блоке кода.</div><div class="block-code"><pre><code class="language-js">var settings = {
    "property": "height-down",
    "base": 16,
    "line": 1.5,
    "resize": true,
    "resizeWidth": true
};
var irhythm = new Rhythm(settings);
// Document ready callback
irhythm.ready(function() {
    var fix = function() {
        // Fix Vertical Rhythm
        irhythm.rhythm("#content img, #content iframe");
    };
    // Need to wait before browser calculate styles and can return getComputeredStyle.
    window.setTimeout(fix, 1000);
});

// Или window load callback
irhythm.load(function() {
    var fix = function() {
        // Fix Vertical Rhythm
        irhythm.rhythm("#content img, #content iframe");
    };
    // Need to wait before browser calculate styles and can return getComputeredStyle.
    window.setTimeout(fix, 500);
});
</code></pre></div><h3>Проблема округления относительных значений</h3><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QMfaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzEzMiA3OS4xNTkyODQsIDIwMTYvMDQvMTktMTM6MTM6NDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkI3MEQ1NDNCMUFDRjExRTdCMEFGRDk2NThBM0Y0MkU0IiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkI3MEQ1NDNBMUFDRjExRTdCMEFGRDk2NThBM0Y0MkU0IiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1LjUgV2luZG93cyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSI3MUIxOTg3MzczQzI3QTc3OTNFMjkzNTkxMzgzMjQyRiIgc3RSZWY6ZG9jdW1lbnRJRD0iNzFCMTk4NzM3M0MyN0E3NzkzRTI5MzU5MTM4MzI0MkYiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7/7gAOQWRvYmUAZMAAAAAB/9sAhAAGBgYGBwYHCAgHCgsK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" alt="Internet Explorer" class="block-left"><p>Многие современные браузеры поддерживают технологию <strong>subpixel rendering</strong>. Данная технология позволяет использовать не целые пиксели, а дробные части пикселя, что например может быть использовано для лучшего масштабирования на экранах с высоким разрешением. Все хорошо до тех пор пока мы используем целые значения в пикселях, но если мы использует единицы измерения rem и em, то браузер их переводит в виртуальные пиксели. И самая большая проблема заключается в том, что все браузеры округляют относительные значения по-разному. Если в Chrome, Firefox и на большинстве мобильных устройств погрешность округления в районе 0.005 пикселя, то браузеры фирмы Microsoft отличились, как всегда, больше всех. Особенно это заметно на значениях размера шрифта в em меньше 1. При значениях в rem менее заметно, что текст начинает плыть относительно сетки, так как все масштабируется относительно размера шрифта тега html и происходит меньше относительных вычислений, по сравнению с em. А вот с em все хуже, и к концу документа можно увидеть насколько сместился текст относительно сетки. На фото выше представлено фото округления значений в IE9 - EDGE из блока кода ниже. Самый маразм браузеров фирмы Microsoft заключается в том, что одни и те же значения в отступах и межстрочном интервале округляются и рендерятся по разному! Microsoft утверждают с каждой новой версией своего браузера, что переписывают движок, но мне верится в это с трудом, так как такое поведение наблюдается во всех последних браузерах Microsoft. В IE8 нет такой проблемы и там округление идет до целых пикселей. Но в IE6-7 есть проблема с округлением свойства border с <strong>em</strong> значениями.</p><div class="block-code"><pre><code class="language-css">.block {
    font-size: 0.8333em;
    line-height: 1.8001em;
    margin-top: 1.8001em;
    margin-bottom: 1.8001em;
    padding-left: 1.8001em;
    padding-right: 1.8001em;
}</code></pre></div><p>Для решения данной проблемы в rhythm включен метод <strong>fix</strong>, который округлит все значения указанных в настройках свойств до целых пикселей. Метод принимает первым параметром перечисленные через запятую селекторы, для которых необходимо пересчитать значения. Второй параметр может быть true или false, и обозначает это статические элементы или нет(по умолчанию true - статические). Статические элементы - это элементы, которые имеют общий стиль и не меняют своих размеров, например кнопки. Если статические элементы, то селектор разделяется на отдельные селекторы, в которых берутся только значения первого элемента, а дальше создается css стиль содержащий селектор. Если элементы не статические, то ищутся все элементы и для каждого, создается отдельный class. Статические элементы работают быстрее так, как создается меньше css стилей. Вы можете использовать оба похода, например true для статических элементов, и false для динамически изменяющихся.</p><div class="block-info">Метод Fix был исключен из библиотеки rhythm из-за бесполезности при динамически изменяемом viewport. Рекомендуется использовать линейку на основе градиента, которая точнее подстраивается под относительные размеры. Но проблема периодически возникает особенно на маленьких экранах.</div><p><img src="images/perfomance.jpg" alt="perfomance" width="300" height="168" class="block-left">Если вы переживаете за производительность, то код работает практически мгновенно. Смотрите картинку слева. Код был максимально оптимизирован и такой результат оптимизации многими программистам просто не достижим.</p><div class="block-info">Метод <strong>fix</strong> желательно использовать перед методом <strong>rhythm</strong>. Это необходимо например, если вы их применяете для одного и того же элемента и вам нужны правильные отступы в методе rhythm.</div></section></main></div><footer class="footer"><div id="copyright"><a class="footer-link" href="#" title="Copyright © 2017 PostCSS Hamster. All rights reserved.">Copyright © 2017 PostCSS Hamster. All rights reserved.</a></div></footer><script src="app.min.js"></script></body></html>